#include "utils.h"
#include "memory.h"

SETUP_
{
	rand_init(4516);
}

TEST_(segment_point_dist) {
	Segment s = {{0.0f, 10.0f}, {0.0f, -10.0f}};
	Vector2 p1 = {-7.0f, 3.0f};
	Vector2 p2 = {7.0f, -4.0f};
	Vector2 p3 = {-19.0f, 18.0f};
	Vector2 p4 = {19.0f, -18.0f};

	float d1 = segment_point_dist(s, p1);
	float d2 = segment_point_dist(s, p2);
	float d3 = segment_point_dist(s, p3);
	float d4 = segment_point_dist(s, p4);

	ASSERT_(d1 == abs(d2));
	ASSERT_(d3 == abs(d4));
}

TEST_(segment_intersect) {
	Segment s1 = {{1.0f, 5.0f}, {4.0f, 5.0f}};
	Segment s2 = {{4.0f, 5.0f}, {4.0f, 3.0f}};
	Segment s3 = {{4.0f, 2.0f}, {4.0f, 1.0f}};
	Segment s4 = {{2.0f, 2.0f}, {5.0f, 4.0f}};
	Segment s5 = {{3.0f, 2.0f}, {5.0f, 1.0f}};

	Vector2 p;
	ASSERT_(segment_intersect(s1, s2, &p) == true);
	ASSERT_(p.x == 4.0f && p.y == 5.0f);
	ASSERT_(segment_intersect(s2, s3, NULL) == false);
	ASSERT_(segment_intersect(s3, s2, NULL) == false);
	ASSERT_(segment_intersect(s2, s4, NULL) == true);
	ASSERT_(segment_intersect(s4, s2, NULL) == true);
	ASSERT_(segment_intersect(s3, s4, NULL) == false);
	ASSERT_(segment_intersect(s4, s3, NULL) == false);
	ASSERT_(segment_intersect(s3, s5, NULL) == true);
	ASSERT_(segment_intersect(s5, s3, NULL) == true);
	ASSERT_(segment_intersect(s4, s5, NULL) == false);
	ASSERT_(segment_intersect(s5, s4, NULL) == false);
}

TEST_(rand_int)
{
	int i;
	for(i = 0; i < 1000; ++i) {
		int r = rand_int(-11, 8512); 
		ASSERT_(r >= -11 && r <= 8512); 
	}	
}

TEST_(rand_float)
{
	float avg = 0.0f;
	
	int i;
	for(i = 0; i < 50000; ++i) {
		float r = rand_float();
		ASSERT_(r >= 0.0f && r <= 1.0f);
		avg += r;
	}	

	avg = (avg / 50000.0f) - 0.5f;
	ASSERT_(avg >= -0.001f && avg <= 0.001f);
}

TEST_(rand_float_range)
{
	int i;
	for(i = 0; i < 1000; ++i) {
		float r = rand_float_range(-489.0f, 41728.0f);
		ASSERT_(r >= -489.0f && r <= 41728.0f);
	}	
}

TEST_(compression_and_decompression)
{
	char data[1000];
	char* compr_data;
	uint compr_size;

	char* decompr_data;
	uint decompr_size;

	int i;
	for(i = 0; i < 1000; ++i) {
		data[i] = (char)rand_int(0, 10);
	}	

	compr_data = lz_compress(&data[0], 1000, &compr_size);
	ASSERT_(compr_data);
	ASSERT_(compr_size < 1000);

	decompr_data = lz_decompress(compr_data, compr_size, &decompr_size);
	ASSERT_(decompr_data);
	ASSERT_(decompr_size == 1000);

	for(i = 0; i < 1000; ++i) {
		ASSERT_(data[i] == decompr_data[i]);
	}	

	MEM_FREE(compr_data);
	MEM_FREE(decompr_data);
}

bool _close(Color c1, Color c2) {
	uint cycles = 4;
	while(cycles--) {
		int d = (c1 & 0xFF) - (c2 & 0xFF);
		if(abs(d) > 1)
			return false;
		c1 >>= 8; c2 >>= 8;
	}
	return true;
}	

TEST_(rgb_hsv) {
	Color c1 = COLOR_RGBA(0, 0, 0, 0);
	Color c2 = COLOR_RGBA(255, 255, 255, 255);
	Color c3 = COLOR_RGBA(195, 31, 5, 0);
	Color c4 = COLOR_RGBA(95, 249, 111, 0);
	Color c5 = COLOR_RGBA(0, 145, 18, 0);
	Color c6 = COLOR_RGBA(1, 254, 1, 254);

	ASSERT_(_close(hsv_to_rgb(rgb_to_hsv(c1)), c1));
	ASSERT_(_close(hsv_to_rgb(rgb_to_hsv(c2)), c2));
	ASSERT_(_close(hsv_to_rgb(rgb_to_hsv(c3)), c3));
	ASSERT_(_close(hsv_to_rgb(rgb_to_hsv(c4)), c4));
	ASSERT_(_close(hsv_to_rgb(rgb_to_hsv(c5)), c5));
	ASSERT_(_close(hsv_to_rgb(rgb_to_hsv(c6)), c6));
}	

TEST_(endianess) {
	uint16 a = 0x0011;
	uint32 b = 0x00112233;

	a = endian_swap2(a);
	b = endian_swap4(b);

	byte* ba = (byte*)&a;
	ASSERT_(ba[0] == 0x11);
	ASSERT_(ba[1] == 0x00);

	byte* bb = (byte*)&b;
	ASSERT_(bb[0] == 0x33);
	ASSERT_(bb[1] == 0x22);
	ASSERT_(bb[2] == 0x11);
	ASSERT_(bb[3] == 0x00);
}	

